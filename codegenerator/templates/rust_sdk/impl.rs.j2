// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
//
// WARNING: This file is automatically generated from OpenAPI schema using
// `openstack-codegenerator`.
{% import 'rust_macros.j2' as macros with context -%}
{{ macros.mod_docstring(command_description) }}
use derive_builder::Builder;
use http::{HeaderMap, HeaderName, HeaderValue};

use crate::api::rest_endpoint_prelude::*;

{% for mod in type_manager.get_imports() | sort %}
use {{ mod }};
{%- endfor %}

{% if is_json_patch %}
use json_patch::Patch;
{%- endif %}

{%- if operation_type == "list" and "limit" in type_manager.parameters.keys() or "marker" in type_manager.parameters.keys() %}
use crate::api::Pageable;
{%- endif %}

{%- include "rust_sdk/subtypes.j2" %}

{%- include "rust_sdk/request_struct.j2" %}

{%- with request = type_manager.get_root_data_type() %}
impl{{ type_manager.get_request_static_lifetimes(request) }} Request{{ type_manager.get_request_static_lifetimes(request) }} {
    /// Create a builder for the endpoint.
    pub fn builder() -> RequestBuilder{{ type_manager.get_request_static_lifetimes(request) }} {
        RequestBuilder::default()
    }
}

impl{{ type_manager.get_request_static_lifetimes(request) }} RequestBuilder{{ type_manager.get_request_static_lifetimes(request) }} {

{%- for param in type_manager.parameters.values() %}
{%- if param.setter_type == "csv" %}
    {{ macros.docstring(param.description, indent=4) }}
    pub fn {{param.setter_name}}<I, T>(&mut self, iter: I) -> &mut Self
    where
        I: Iterator<Item = T>,
        T: Into<{{ param.data_type.item_type.type_hint }}>,
    {
    self.{{param.setter_name}}
    .get_or_insert(None)
    .get_or_insert_with(CommaSeparatedList::new)
    .extend(iter.map(Into::into));
    self
    }
{%- elif param.setter_type=="set" %}
    {{ macros.docstring(param.description, indent=4) }}
    pub fn {{param.setter_name}}<I, T>(&mut self, iter: I) -> &mut Self
    where
        I: Iterator<Item = T>,
        T: Into<{{ param.data_type.item_type.type_hint }}>,
    {
    self.{{ param.setter_name }}
    .get_or_insert_with(BTreeSet::new)
    .extend(iter.map(Into::into));
    self
    }
{%- elif param.setter_type == "list" %}
    {{ macros.docstring(param.description, indent=4) }}
    pub fn {{param.setter_name}}<I, T>(&mut self, iter: I) -> &mut Self
    where
        I: Iterator<Item = T>,
        T: Into<{{ param.data_type.item_type.type_hint }}>,
    {
    self.{{param.setter_name}}
    {%- if not param.is_required %}
    .get_or_insert(None)
    {%- endif %}
    .get_or_insert_with(Vec::new)
    .extend(iter.map(Into::into));
    self
    }
{%- endif %}
{%- endfor %}

{%- if request.fields is defined %}
  {%- for field in request.fields.values() %}
    {%- if "private" in field.builder_macros %}
      {{ macros.sdk_builder_setter(field)}}
    {%- endif %}
  {%- endfor %}
{%- endif %}

    /// Add a single header to the {{ class_name }}.
    pub fn header(&mut self, header_name: &'static str, header_value: &'static str) -> &mut Self
    where {
        self._headers
            .get_or_insert(None)
            .get_or_insert_with(HeaderMap::new)
            .insert(header_name, HeaderValue::from_static(header_value));
        self
    }

    /// Add multiple headers.
    pub fn headers<I, T>(&mut self, iter: I) -> &mut Self
    where
        I: Iterator<Item = T>,
        T: Into<(Option<HeaderName>, HeaderValue)>,
    {
        self._headers
            .get_or_insert(None)
            .get_or_insert_with(HeaderMap::new)
            .extend(iter.map(Into::into));
        self
    }

  {% if request.additional_fields_type is defined and request.additional_fields_type %}
    pub fn properties<I, K, V>(&mut self, iter: I) -> &mut Self
      where
          I: Iterator<Item = (K, V)>,
          K: Into<Cow<'a, str>>,
          V: Into<{{ request.additional_fields_type.type_hint }}>,
      {
          self._properties
              .get_or_insert_with(BTreeMap::new)
              .extend(iter.map(|(k, v)| (k.into(), v.into())));
          self
      }

  {%- endif %}

  {%- if request.__class__.__name__ == "BTreeMap" %}
    pub fn properties<I, K, V>(&mut self, iter: I) -> &mut Self
      where
          I: Iterator<Item = (K, V)>,
          K: Into<Cow<'a, str>>,
          V: Into<{{ request.value_type.type_hint }}>,
      {
          self._properties
              .get_or_insert_with(BTreeMap::new)
              .extend(iter.map(|(k, v)| (k.into(), v.into())));
          self
      }

  {%- endif %}
}

impl{{ type_manager.get_request_static_lifetimes(request) }} RestEndpoint for Request{{ type_manager.get_request_static_lifetimes(request) }} {
    fn method(&self) -> http::Method {
        http::Method::{{ method | upper }}
    }

    fn endpoint(&self) -> Cow<'static, str> {
      {{ macros.sdk_build_url(url, type_manager.parameters, "", true) }}.into()
    }

    fn parameters(&self) -> QueryParams {
    {%- if type_manager.parameters.values()|selectattr("location", "equalto", "query")|list|length > 0 %}
        let mut params = QueryParams::default();

     {%- for param in type_manager.parameters.values() %}
     {%- if param.location == "query" %}
     {%- if param.data_type.__class__.__name__ == "Null" %}
     params.push_opt_key_only(
         "{{ param.remote_name }}",
         self.{{ param.local_name }}.as_ref()
     );
     {%- elif not param.type_hint.startswith("BTreeSet") %}
     params.push_opt(
         "{{ param.remote_name }}",
         self.{{ param.local_name}}
         {%- if "Cow<" in param.type_hint %}
         .as_ref()
         {%- endif %}
     );
     {%- else %}
     params.extend(self.{{ param.local_name }}.iter().map(|value| ("{{ param.remote_name }}", value)));
     {%- endif %}
     {%- endif %}
     {%- endfor %}

        params
    {%- else %}
        QueryParams::default()
    {%- endif %}
    }

{% if request.fields is defined and request.fields %}
    fn body(&self) -> Result<Option<(&'static str, Vec<u8>)>, BodyError> {
        let mut params = JsonBodyParams::default();

        {% for k, v in request.fields.items() %}
        {%- if v.data_type.__class__.__name__ != "Null" %}
        {%- if v.is_optional %}
        if let Some(val) = &self.{{ v.local_name }} {
            params.push("{{ k }}", serde_json::to_value(val)?);
        }
        {%- else %}
        params.push("{{ k }}", serde_json::to_value(&self.{{v.local_name}})?);
        {%- endif %}
        {%- else %}
        params.push("{{ k }}", Value::Null);
        {%- endif %}
        {%- endfor %}

  {%- if request.additional_fields_type %}
        for (key, val) in &self._properties {
            params.push(key.clone(), serde_json::Value::from(val.clone()));
        }
  {%- endif %}

        params.into_body()
    }
{% elif is_json_patch %}
    fn body(&self) -> Result<Option<(&'static str, Vec<u8>)>, BodyError> {
        Ok(Some((
            "{{ mime_type }}",
            serde_json::to_string(&self.patch)?.into_bytes(),
        )))
    }

{%- elif request.__class__.__name__ == "BTreeMap" %}
    fn body(&self) -> Result<Option<(&'static str, Vec<u8>)>, BodyError> {
        let mut params = JsonBodyParams::default();

        for (key, val) in &self._properties {
            params.push(key.clone(), serde_json::Value::from(val.clone()));
        }

        params.into_body()
    }
{%- endif %}

    fn service_type(&self) -> ServiceType {
      ServiceType::{{ sdk_service_name }}
    }

    fn response_key(&self) -> Option<Cow<'static, str>> {
{%- if response_key %}
        Some("{{ response_key }}".into())
{%- else %}
        None
{%- endif %}
    }

{% if response_list_item_key %}
    fn response_list_item_key(&self) -> Option<Cow<'static, str>> {
        Some("{{ response_list_item_key }}".into())
    }
{%- endif %}

    /// Returns headers to be set into the request
    fn request_headers(&self) -> Option<&HeaderMap> {
        self._headers.as_ref()
    }
}

{#- EP is pageable if operation_type is list and there is limit or marker query parameter #}
{%- if operation_type == "list" and "limit" in type_manager.parameters.keys() or "marker" in type_manager.parameters.keys() %}
impl{{ type_manager.get_request_static_lifetimes(request) }} Pageable for Request{{ type_manager.get_request_static_lifetimes(request) }} {}
{%- endif %}

#[cfg(test)]
mod tests {
    #![allow(unused_imports)]
    use super::*;
{%- if method.upper() == "HEAD" %}
    use crate::api::RawQuery;
{%- else %}
    use crate::api::Query;
    use serde_json::json;
{%- endif %}
    use crate::types::ServiceType;
    use crate::test::client::MockServerClient;
    use http::{HeaderName, HeaderValue};
    {%- if is_json_patch %}
    use serde_json::from_value;
    use json_patch::Patch;
    {%- endif %}

    #[test]
    fn test_service_type() {
        assert_eq!(Request::builder()
            {{ ".patch(from_value::<Patch>(json!([])).unwrap())" if is_json_patch else "" }}
            {{ request.get_mandatory_init() }}
            .build().unwrap().service_type(), ServiceType::{{ sdk_service_name }});
    }

    #[test]
    fn test_response_key() {
{%- if response_key %}
        assert_eq!(
            Request::builder()
                {{ ".patch(from_value::<Patch>(json!([])).unwrap())" if is_json_patch else "" }}
                {{ request.get_mandatory_init() }}
                .build().unwrap().response_key().unwrap(),
            "{{ response_key }}"
        );
{%- else %}
        assert!(Request::builder()
            {{ ".patch(from_value::<Patch>(json!([])).unwrap())" if is_json_patch else "" }}
            {{ request.get_mandatory_init() }}
            .build().unwrap().response_key().is_none())
{%- endif %}
    }

    #[test]
    fn endpoint() {
        let client = MockServerClient::new();
        let mock = client.server.mock(|when, then| {
            when.method(httpmock::Method::{{ method | upper }})
            .path({{ macros.sdk_build_url(url, type_manager.parameters, "/") }});

            then.status(200)
                .header("content-type", "application/json")
{%- if method.upper() != "HEAD" %}
                .json_body(json!({ "{{ response_key or "dummy" }}": {} }))
{%- endif %};
        });

        let endpoint = Request::builder()
            {%- for k, v in type_manager.parameters.items() %}
            {%- if v.location == "path" %}
            .{{ v.local_name }}("{{ k }}")
            {%- endif %}
            {%- endfor %}
            {{ ".patch(from_value::<Patch>(json!([])).unwrap())" if is_json_patch else "" }}
            {{ request.get_mandatory_init() }}
            .build().unwrap();
{%- if method.upper() != "HEAD" %}
        let _: serde_json::Value = endpoint.query(&client).unwrap();
{%- else %}
        let _ = endpoint.raw_query(&client).unwrap();
{%- endif %}
        mock.assert();
    }

    #[test]
    fn endpoint_headers() {
        let client = MockServerClient::new();
        let mock = client.server.mock(|when, then| {
            when.method(httpmock::Method::{{ method|upper }})
                .path({{ macros.sdk_build_url(url, type_manager.parameters, "/") }})
                .header("foo", "bar")
                .header("not_foo", "not_bar");
            then.status(200)
                .header("content-type", "application/json")
{%- if method.upper() != "HEAD" %}
                .json_body(json!({ "{{ response_key or "dummy" }}": {} }))
{%- endif %};
        });

        let endpoint = Request::builder()
            {%- for k, v in type_manager.parameters.items() %}
            {%- if v.location == "path" %}
            .{{ v.local_name }}("{{ k }}")
            {%- endif %}
            {%- endfor %}
            {{ ".patch(from_value::<Patch>(json!([])).unwrap())" if is_json_patch else "" }}
            {{ request.get_mandatory_init() }}
            .headers(
                [(
                    Some(HeaderName::from_static("foo")),
                    HeaderValue::from_static("bar"),
                )]
                .into_iter(),
            )
            .header("not_foo", "not_bar")
            .build()
            .unwrap();
{%- if method.upper() != "HEAD" %}
        let _: serde_json::Value = endpoint.query(&client).unwrap();
{%- else %}
        let _ = endpoint.raw_query(&client).unwrap();
{%- endif %}
        mock.assert();
    }
}

{%- endwith %}
